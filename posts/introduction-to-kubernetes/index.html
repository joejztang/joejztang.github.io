<!doctype html><html lang=en><head><title>introduction to kubernetes · 130l</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="130l"><meta name=description content="
  kubernetes architecture
  
    
    Link to heading
  


one or more master nodes
one or more worker nodes
distributed key - value storage (for state purposes)


  master nodes
  
    
    Link to heading
  

master nodes are entry point for administrative tasks. if there are more master nodes, then it would be in HA (high availability) mode.
in this time, one of them is a &rsquo;leader&rsquo; and others are followers."><meta name=keywords content="blog,science,technology,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="introduction to kubernetes"><meta name=twitter:description content="kubernetes architecture Link to heading one or more master nodes one or more worker nodes distributed key - value storage (for state purposes) master nodes Link to heading master nodes are entry point for administrative tasks. if there are more master nodes, then it would be in HA (high availability) mode.
in this time, one of them is a ’leader’ and others are followers."><meta property="og:url" content="http://www.example.com/posts/introduction-to-kubernetes/"><meta property="og:site_name" content="130l"><meta property="og:title" content="introduction to kubernetes"><meta property="og:description" content="kubernetes architecture Link to heading one or more master nodes one or more worker nodes distributed key - value storage (for state purposes) master nodes Link to heading master nodes are entry point for administrative tasks. if there are more master nodes, then it would be in HA (high availability) mode.
in this time, one of them is a ’leader’ and others are followers."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-04-19T16:54:16+00:00"><meta property="article:modified_time" content="2019-04-19T16:54:16+00:00"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Cheating Sheet"><link rel=canonical href=http://www.example.com/posts/introduction-to-kubernetes/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.4b392a85107b91dbdabc528edf014a6ab1a30cd44cafcd5325c8efe796794fca.css integrity="sha256-SzkqhRB7kdvavFKO3wFKarGjDNRMr81TJcjv55Z5T8o=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/img/favicon.svg sizes=any><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=http://www.example.com/>130l
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Posts</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=http://www.example.com/posts/introduction-to-kubernetes/>introduction to kubernetes</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2019-04-19T16:54:16Z>April 19, 2019
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
10-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/kubernetes/>Kubernetes</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/cheating-sheet/>Cheating Sheet</a></span></div></div></header><div class=post-content><h2 id=kubernetes-architecture>kubernetes architecture
<a class=heading-link href=#kubernetes-architecture><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li>one or more master nodes</li><li>one or more worker nodes</li><li>distributed key - value storage (for state purposes)</li></ul><h3 id=master-nodes>master nodes
<a class=heading-link href=#master-nodes><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>master nodes are entry point for administrative tasks. if there are more master nodes, then it would be in HA (high availability) mode.</p><p>in this time, one of them is a &rsquo;leader&rsquo; and others are followers.</p><p>all master nodes connect to distributed key-value storage. kubernetes is using etcd. the aim is to manage the cluster state.</p><p>a master node has following components:</p><ul><li>API server: user send admin task to kubernetes. API server receive the requests, validates and processes them. finally, the result will be storing in etcd</li><li>scheduler: schedules the work to different worker nodes. scheduler schedules the work in term of pods and services.</li><li>controller manager: manage different control loops. each of control loops knows about the desired state of the objects it manages, and watches their current state through API server. corrective steps will be performed if the state is not the desired state.</li><li>etcd: stores cluster state, configuration details.</li></ul><h3 id=worker-nodes>worker nodes
<a class=heading-link href=#worker-nodes><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>a worker node is a machine runs applications using pods. it is controlled by the master node.</p><p>a Pod is the scheduling unit in k8s. it is a logical collection of one or more containers which are always scheduled together.</p><p>a worker node has the following components:</p><ul><li>container runtime: examples of container runtimes are <code>containerd, rkt, lxd</code>. docker is using <code>containerd</code></li><li>kubelet:
kubelet communicates with master node. it receives pod defination that api server sends, and runs the containers associated with the pod.
kubelet connects to container runtime using <strong>Container Runtime Interface <a href=https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/ class=external-link target=_blank rel=noopener>(CRI)</a></strong>
<img src=/images/kubelet.PNG alt=CRI><ul><li>cri shims: <code>dockershim</code> and <code>cri-containerd</code></li></ul></li><li>kube-proxy:</li></ul><h2 id=network-setup-challenges>network setup challenges
<a class=heading-link href=#network-setup-challenges><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li>a unique ip is assigned to each pod</li><li>containers in a pod can communicate to each other</li><li>the pod is able to commuicate with other pods in the cluster</li><li>if configured, the application deployed inside a pod is accessible from the external world.</li></ul><h3 id=set-a-unique-ip-to-each-pod>set a unique ip to each pod
<a class=heading-link href=#set-a-unique-ip-to-each-pod><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>container runtime offloads ip assignment to CNI, which connects to underlying plugins. once the ip address is given by respective plugin, CNI forwards it back to the requested container runtime.</p><p><img src=/images/cni.png alt=cni></p><h3 id=containers-communications-inside-pod>containers communications inside pod
<a class=heading-link href=#containers-communications-inside-pod><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>inside a pod, containers share the network namespaces, so that they can reach to each other via localhost.</p><h3 id=pod-to-pod-communication>pod to pod communication
<a class=heading-link href=#pod-to-pod-communication><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li>routable pods and nodes, using the underlying physical infrastructure</li><li>using software defined networking, like Flannel, Weave, Calico</li></ul><h3 id=pod-communicates-to-outside-world>pod communicates to outside world
<a class=heading-link href=#pod-communicates-to-outside-world><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>using kube-proxy</p><h2 id=different-kubernetes-configurations>different kubernetes configurations
<a class=heading-link href=#different-kubernetes-configurations><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li>all-in-one single node installation: Minikube. it is useful for development</li><li>single-node etcd, single master and multiple workers</li><li>single-node etcd, multiple masters and multiple workers</li><li>multi-node etcd, mutiple masters and multiple workers</li></ul><h2 id=pod>pod
<a class=heading-link href=#pod><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>a pod is the smallest and simplest kubernetes object. It is the unit of deployment in Kubernetes, which represents a single instance of the application. A Pod is a logical collection of one or more containers.</p><p><img src=/images/pods.png alt=pods></p><h2 id=labels>labels
<a class=heading-link href=#labels><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>labels are key-value pairs that attached to any kubernets object. Labels are used to organize and select a subset of objects, based on the requirements in place. Many objects can have the same Label(s)</p><p>also we can use label selector to select object with certain labels, eg: <code>'env==dev'</code></p><h2 id=replicationcontrollers>ReplicationControllers
<a class=heading-link href=#replicationcontrollers><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>a ReplicationController (rc) is a part of master node&rsquo;s controller manager. rc will create or kill pods to match the desire count set by us. we always use controllers like rc to create and manage pods.</p><h2 id=replicaset>ReplicaSet
<a class=heading-link href=#replicaset><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>A ReplicaSet (rs) is a next generation ReplicationController.</p><p><img src=/images/replicaset.png alt=rs></p><h2 id=deployments>deployments
<a class=heading-link href=#deployments><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Deployment objects provide declarative updates to Pods and ReplicaSets. The DeploymentController is part of the master node&rsquo;s controller manager, and it makes sure that the current state always matches the desired state.</p><p><img src=/images/deployment.png alt=deployment></p><h3 id=deployment-rollout>deployment rollout
<a class=heading-link href=#deployment-rollout><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>a <strong>rollout</strong> is a update on deployment object. eg, if we update image from 1.7.9 to 1.9.1, then a rollout happens.</p><p><img src=/images/rollout.png alt=rollout></p><p>after <strong>rollout</strong> happens, deployment will keep monitoring ReplicaSet and <strong>rollback</strong> to previous known status.</p><h2 id=namespaces>namespaces
<a class=heading-link href=#namespaces><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>If we have numerous users whom we would like to organize into teams/projects, we can partition the Kubernetes cluster into sub-clusters using Namespaces.</p><p>To list all the Namespaces, we can run the following command:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl get namespaces
</span></span><span style=display:flex><span>NAME          STATUS       AGE
</span></span><span style=display:flex><span>default       Active       11h
</span></span><span style=display:flex><span>kube-public   Active       11h
</span></span><span style=display:flex><span>kube-system   Active       11h
</span></span></code></pre></div><p>Generally, Kubernetes creates two default Namespaces: <code>kube-system</code> and <code>default</code>. The <code>kube-system</code> Namespace contains the objects created by the Kubernetes system. The <code>default</code> Namespace contains the objects which belong to any other Namespace. By default, we connect to the <code>default</code> Namespace. <code>kube-public</code> is a special Namespace, which is readable by all users and used for special purposes, like bootstrapping a cluster.</p><h2 id=authentication>authentication
<a class=heading-link href=#authentication><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>kubernetes has two kinds of users:</p><ul><li>normal users: normal users were managed outside of k8s clusters.</li><li>service accounts: they are used to in-cluster communications with the API server.</li></ul><p>there are different authentication module that can be used.</p><h2 id=services>services
<a class=heading-link href=#services><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=label-selector>label selector
<a class=heading-link href=#label-selector><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>label selector is important here. because pods are ephermal in nature, so that there cannot be static ip. so when user wants to connect to pods, kubernets uses a level of abstract to find it &ndash; <strong>services</strong>. the problem is how to find it? since the pods are with ephermal nature. Using <strong>label selector</strong>.</p><h3 id=kube-proxy>kube-proxy
<a class=heading-link href=#kube-proxy><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>All of the worker nodes run a daemon called kube-proxy, which watches the API server on the master node for the addition and removal of Services and endpoints.</p><h3 id=service-discovery>service discovery
<a class=heading-link href=#service-discovery><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>kubernetes has an add-on for DNS, which created a DNS record for each service and an string with specific format so that service under same namespace can access others just use their names.</p><p>other pods from other namespace can access this pod using name with namespace suffix.</p><h3 id=service-type>service type
<a class=heading-link href=#service-type><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><code>cluster IP</code> and <code>nodePort</code></p><p>The <code>NodePort</code> ServiceType is useful when we want to make our Services accessible from the external world.</p><p><code>LoadBalancer</code></p><p><code>ExternalIP</code></p><p>Please note that ExternalIPs are not managed by Kubernetes. The cluster administrators has configured the routing to map the ExternalIP address to one of the nodes.</p><p><code>External Name</code></p><h2 id=useful-commands>useful commands
<a class=heading-link href=#useful-commands><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># list the deployments</span>
</span></span><span style=display:flex><span>kubectl get deployments
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># list the replicas</span>
</span></span><span style=display:flex><span>kubectl get replicasets
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># list the pods</span>
</span></span><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><ul><li>look at the pods details</li></ul><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl describe pod webserver-74d8bd488f-dwbzz
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Name:           webserver-74d8bd488f-dwbzz
</span></span><span style=display:flex><span>Namespace:      default
</span></span><span style=display:flex><span>Node:           minikube/192.168.99.100
</span></span><span style=display:flex><span>Start Time:     Thu, <span style=color:#a5d6ff>22</span> Mar <span style=color:#a5d6ff>2018</span> 09:17:33 +0530
</span></span><span style=display:flex><span>Labels:         k8s-app<span style=color:#ff7b72;font-weight:700>=</span>webserver
</span></span><span style=display:flex><span>                pod-template-hash<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>3084680449</span>
</span></span><span style=display:flex><span>Annotations:    &lt;none&gt;
</span></span><span style=display:flex><span>Status:         Running
</span></span><span style=display:flex><span>IP:             172.17.0.5
</span></span><span style=display:flex><span>Controlled By:  ReplicaSet/webserver-74d8bd488f
</span></span><span style=display:flex><span>Containers:
</span></span><span style=display:flex><span>  webserver:
</span></span><span style=display:flex><span>    Container ID:   docker://96302d70903fe3b45d5ff3745a706d67d77411c5378f1f293a4bd721896d6420
</span></span><span style=display:flex><span>    Image:          nginx:alpine
</span></span><span style=display:flex><span>    Image ID:       docker-pullable://nginx@sha256:8d5341da24ccbdd195a82f2b57968ef5f95bc27b3c3691ace0c7d0acf5612edd
</span></span><span style=display:flex><span>    Port:           &lt;none&gt;
</span></span><span style=display:flex><span>    State:          Running
</span></span><span style=display:flex><span>      Started:      Thu, <span style=color:#a5d6ff>22</span> Mar <span style=color:#a5d6ff>2018</span> 09:17:33 +0530
</span></span><span style=display:flex><span>    Ready:          True
</span></span><span style=display:flex><span>    Restart Count:  <span style=color:#a5d6ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># list the pods with the attached labels</span>
</span></span><span style=display:flex><span>$ kubectl get pods -L k8s-app,label2
</span></span><span style=display:flex><span>NAME                         READY   STATUS    RESTARTS   AGE   K8S-APP     LABEL2
</span></span><span style=display:flex><span>webserver-74d8bd488f-dwbzz   1/1     Running   <span style=color:#a5d6ff>0</span>          14m   webserver   &lt;none&gt;
</span></span><span style=display:flex><span>webserver-74d8bd488f-npkzv   1/1     Running   <span style=color:#a5d6ff>0</span>          14m   webserver   &lt;none&gt;
</span></span><span style=display:flex><span>webserver-74d8bd488f-wvmpq   1/1     Running   <span style=color:#a5d6ff>0</span>          14m   webserver   &lt;none&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># list the pods with label level set to webserver</span>
</span></span><span style=display:flex><span>$ kubectl get pods -l k8s-app<span style=color:#ff7b72;font-weight:700>=</span>webserver
</span></span><span style=display:flex><span>NAME                         READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>webserver-74d8bd488f-dwbzz   1/1       Running   <span style=color:#a5d6ff>0</span>          17m
</span></span><span style=display:flex><span>webserver-74d8bd488f-npkzv   1/1       Running   <span style=color:#a5d6ff>0</span>          19m
</span></span><span style=display:flex><span>webserver-74d8bd488f-wvmpq   1/1       Running   <span style=color:#a5d6ff>0</span>          17m
</span></span></code></pre></div><ul><li>delete deployments</li></ul><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl delete deployments webserver
</span></span><span style=display:flex><span>deployment <span style=color:#a5d6ff>&#34;webserver&#34;</span> deleted
</span></span></code></pre></div><ul><li>create a deployment</li></ul><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl create -f webserver.yaml
</span></span><span style=display:flex><span>deployment <span style=color:#a5d6ff>&#34;webserver&#34;</span> created
</span></span></code></pre></div><p><code>webserver.yaml</code> will be like below:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#7ee787>apiVersion</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>apps/v1</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#7ee787>kind</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>Deployment</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#7ee787>metadata</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>name</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>webserver</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>labels</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#7ee787>app</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>nginx</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#7ee787>spec</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>replicas</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>3</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>selector</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#7ee787>matchLabels</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>app</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>nginx</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>template</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#7ee787>metadata</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>labels</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#7ee787>app</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>nginx</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#7ee787>spec</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>containers</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span>- <span style=color:#7ee787>name</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>nginx</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#7ee787>image</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>nginx:alpine</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#7ee787>ports</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>- <span style=color:#7ee787>containerPort</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>80</span><span style=color:#6e7681>
</span></span></span></code></pre></div><p>the command above will also create replicasets and pods.</p><ul><li>exporting specific port to outside world</li></ul><p>from above we see how to create a deployment from a yaml file. with <code>ServiceType</code> we can define the access mode of a given Service.</p><p>with <strong>NodePort</strong> service type, kubenetes opens up a static port on all the worker nodes. let&rsquo;s see <code>yaml</code> file from below:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#7ee787>apiVersion</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>v1</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#7ee787>kind</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>Service</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#7ee787>metadata</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>name</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>web-service</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>labels</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#7ee787>run</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>web-service</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#7ee787>spec</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>type</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>NodePort</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>ports</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>- <span style=color:#7ee787>port</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>80</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#7ee787>protocol</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>TCP</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#7ee787>selector</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#7ee787>app</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>nginx </span><span style=color:#6e7681>
</span></span></span></code></pre></div><ul><li>list the services</li></ul><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl get svc
</span></span><span style=display:flex><span>NAME          TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span style=color:#ff7b72;font-weight:700>(</span>S<span style=color:#ff7b72;font-weight:700>)</span>        AGE
</span></span><span style=display:flex><span>kubernetes    ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        1d
</span></span><span style=display:flex><span>web-service   NodePort    10.110.47.84   &lt;none&gt;        80:31074/TCP   12s
</span></span></code></pre></div><ul><li>get ip of application</li></ul><p><code>minikube ip</code></p><ul><li>access application in browser</li></ul><p><code>minikube service web-service</code></p><ul><li>liveness command</li></ul><p>liveness container will check the health of application</p><p>In the following example, the kubelet sends the HTTP GET request to the /healthz endpoint of the application, on port 8080. If that returns a failure, then the kubelet will restart the affected container; otherwise, it would consider the application to be alive.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#7ee787>livenessProbe</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>httpGet</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#7ee787>path</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>/healthz</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#7ee787>port</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>8080</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#7ee787>httpHeaders</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>- <span style=color:#7ee787>name</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>X-Custom-Header</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>          </span><span style=color:#7ee787>value</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>Awesome</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>initialDelaySeconds</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>3</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>periodSeconds</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>3</span><span style=color:#6e7681>
</span></span></span></code></pre></div><p>so that tcp probe</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#7ee787>livenessProbe</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>tcpSocket</span>:<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span><span style=color:#7ee787>port</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>8080</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>initialDelaySeconds</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>15</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#7ee787>periodSeconds</span>:<span style=color:#6e7681> </span><span style=color:#a5d6ff>20</span><span style=color:#6e7681>
</span></span></span></code></pre></div><ul><li>readiness probe</li></ul><p>readiness probe ensures certain condition occur before application serves traffic.</p><h2 id=volume-management>volume management
<a class=heading-link href=#volume-management><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><blockquote><p>In Kubernetes, a Volume is attached to a Pod and shared among the containers of that Pod.</p></blockquote><ul><li>emptyDir</li></ul><blockquote><p>An empty Volume is created for the Pod as soon as it is scheduled on the worker node. The Volume&rsquo;s life is tightly coupled with the Pod. If the Pod dies, the content of emptyDir is deleted forever.</p></blockquote><ul><li>hostPath</li><li>gcePersistentDisk</li><li>awsElasticBlockStore</li><li>nfs</li><li>iscsi</li><li>secret</li><li>presistentVolumeClaim</li></ul><p>in containerized world, k8s provides APIs for users to interact with <strong>PersistentVolume(PV)</strong></p><h3 id=pvc>PVC
<a class=heading-link href=#pvc><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>a <strong>PersistentVolumeClaim(PVC)</strong> is a request for storage by a user.</p><p><img src=/images/persistentvolumeclaim.PNG alt=persistentvolumeclaim></p><h3 id=container-storage-interface-csi>Container Storage Interface CSI
<a class=heading-link href=#container-storage-interface-csi><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>storage vendors and community members from different orchestrators work together to standardize and form CSI.</p><p>k8s (k8s v1.9) alpha support CSI made it easy to install CSI compliant plugins.</p><h2 id=config-app-using-configmaps>config app using <code>ConfigMaps</code>
<a class=heading-link href=#config-app-using-configmaps><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><code>ConfigMaps</code> allow to decouple the configuration from the container image. we can pass conf as key-value pair.</p><p>examples:</p><ul><li>by literal:</li></ul><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl create configmap my-config --from-literal<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#79c0ff>key1</span><span style=color:#ff7b72;font-weight:700>=</span>value1 --from-literal<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#79c0ff>key2</span><span style=color:#ff7b72;font-weight:700>=</span>value2
</span></span><span style=display:flex><span>configmap <span style=color:#a5d6ff>&#34;my-config&#34;</span> created 
</span></span></code></pre></div><ul><li>by file:</li></ul><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl get configmaps my-config -o yaml
</span></span><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>data:
</span></span><span style=display:flex><span>  key1: value1
</span></span><span style=display:flex><span>  key2: value2
</span></span><span style=display:flex><span>kind: ConfigMap
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  creationTimestamp: 2017-05-31T07:21:55Z
</span></span><span style=display:flex><span>  name: my-config
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  resourceVersion: <span style=color:#a5d6ff>&#34;241345&#34;</span>
</span></span><span style=display:flex><span>  selfLink: /api/v1/namespaces/default/configmaps/my-config
</span></span><span style=display:flex><span>  uid: d35f0a3d-45d1-11e7-9e62-080027a46057
</span></span></code></pre></div><h3 id=configuration-file-for-configmap-creation>configuration file for <code>ConfigMap</code> creation
<a class=heading-link href=#configuration-file-for-configmap-creation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>First, we need to create a configuration file. We can have a configuration file with the content like:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: ConfigMap
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: customer1
</span></span><span style=display:flex><span>data:
</span></span><span style=display:flex><span>  TEXT1: Customer1_Company
</span></span><span style=display:flex><span>  TEXT2: Welcomes You
</span></span><span style=display:flex><span>  COMPANY: Customer1 Company Technology Pct. Ltd.
</span></span></code></pre></div><h3 id=create-configmap>create <code>ConfigMap</code>
<a class=heading-link href=#create-configmap><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl create -f customer1-configmap.yaml
</span></span><span style=display:flex><span>configmap <span style=color:#a5d6ff>&#34;customer1&#34;</span> created
</span></span></code></pre></div><h2 id=ingress>Ingress
<a class=heading-link href=#ingress><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Ingress is another method to access the application</p><p>According to kubernetes.io</p><blockquote><p>An Ingress is a collection of rules that allow inbound connections to reach the cluster Services.</p></blockquote><p>here is a diagram explaining what is an ingress</p><p><img src=/images/ingress.PNG alt=ingress></p><p>with ingress, users don&rsquo;t connect directly to a Service, users reach the ingress point first.</p><p>those forwarding action is done by <strong>ingress controller</strong>.</p><h3 id=ingress-controller>Ingress Controller
<a class=heading-link href=#ingress-controller><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><blockquote><p>An Ingress Controller is an application which watches the Master Node&rsquo;s API server for changes in the Ingress resources and updates the Layer 7 Load Balancer accordingly. Kubernetes has different Ingress Controllers, and, if needed, we can also build our own. GCE L7 Load Balancer and Nginx Ingress Controller are examples of Ingress Controllers.</p></blockquote><p>a typical config file would be like this:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apiVersion: extensions/v1beta1
</span></span><span style=display:flex><span>kind: Ingress
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: web-ingress
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  rules:
</span></span><span style=display:flex><span>  - host: blue.example.com
</span></span><span style=display:flex><span>    http:
</span></span><span style=display:flex><span>      paths:
</span></span><span style=display:flex><span>      - backend:
</span></span><span style=display:flex><span>          serviceName: webserver-blue-svc
</span></span><span style=display:flex><span>          servicePort: <span style=color:#a5d6ff>80</span>
</span></span><span style=display:flex><span>  - host: green.example.com
</span></span><span style=display:flex><span>    http:
</span></span><span style=display:flex><span>      paths:
</span></span><span style=display:flex><span>      - backend:
</span></span><span style=display:flex><span>          serviceName: webserver-green-svc
</span></span><span style=display:flex><span>          servicePort: <span style=color:#a5d6ff>80</span>
</span></span></code></pre></div><p>and then create it.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl create -f webserver-ingress.yaml
</span></span></code></pre></div><h2 id=credit-to>credit to
<a class=heading-link href=#credit-to><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li><a href=https://courses.edx.org/courses/course-v1:LinuxFoundationX+LFS158x+1T2018/course/ class=external-link target=_blank rel=noopener>edx k8s course</a></li></ul></div><footer></footer></article></section></div><footer class=footer><section class=container>©
1990 -
2025
130l
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>