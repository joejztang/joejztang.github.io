<!doctype html><html lang=en><head><title>Union Find总结 · 130l</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="130l"><meta name=description content="
  什么是 union find(并查集)
  
    
    Link to heading
  


在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题
&mdash; from Wikipedia

  union find 适用于解决什么问题
  
    
    Link to heading
  

给出节点, 判断他们是否联通, 并且不需要给出具体路径.
如果需要判断是否联通, 并且需要给出具体路径, 那么就需要用 BFS 或者 DFS 来解决了.

  union find 的应用
  
    
    Link to heading
  


判断网络是否联通
lc 200, number of islands


  Union find 设计
  
    
    Link to heading
  

public class UF {
  // init n sites with integer names (0~n-1)
  UF(int n);
  // connect p and q
  void union(int p, int q);
  // find component id of p
  int find(int p);
  // return if p and q is connected
  boolean connected(int p, int q);
  // number of components
  int count();
}
union() 和 connected() 都依赖于 find(), 所以find()要很有效率才行."><meta name=keywords content="blog,science,technology,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Union Find总结"><meta name=twitter:description content="什么是 union find(并查集) Link to heading 在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题 — from Wikipedia
union find 适用于解决什么问题 Link to heading 给出节点, 判断他们是否联通, 并且不需要给出具体路径.
如果需要判断是否联通, 并且需要给出具体路径, 那么就需要用 BFS 或者 DFS 来解决了.
union find 的应用 Link to heading 判断网络是否联通 lc 200, number of islands Union find 设计 Link to heading public class UF { // init n sites with integer names (0~n-1) UF(int n); // connect p and q void union(int p, int q); // find component id of p int find(int p); // return if p and q is connected boolean connected(int p, int q); // number of components int count(); } union() 和 connected() 都依赖于 find(), 所以find()要很有效率才行."><meta property="og:url" content="https://joejztang.github.io/posts/union-find%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="130l"><meta property="og:title" content="Union Find总结"><meta property="og:description" content="什么是 union find(并查集) Link to heading 在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题 — from Wikipedia
union find 适用于解决什么问题 Link to heading 给出节点, 判断他们是否联通, 并且不需要给出具体路径.
如果需要判断是否联通, 并且需要给出具体路径, 那么就需要用 BFS 或者 DFS 来解决了.
union find 的应用 Link to heading 判断网络是否联通 lc 200, number of islands Union find 设计 Link to heading public class UF { // init n sites with integer names (0~n-1) UF(int n); // connect p and q void union(int p, int q); // find component id of p int find(int p); // return if p and q is connected boolean connected(int p, int q); // number of components int count(); } union() 和 connected() 都依赖于 find(), 所以find()要很有效率才行."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-11-22T12:35:47+00:00"><meta property="article:modified_time" content="2018-11-22T12:35:47+00:00"><meta property="article:tag" content="Alg"><link rel=canonical href=https://joejztang.github.io/posts/union-find%E6%80%BB%E7%BB%93/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.4b392a85107b91dbdabc528edf014a6ab1a30cd44cafcd5325c8efe796794fca.css integrity="sha256-SzkqhRB7kdvavFKO3wFKarGjDNRMr81TJcjv55Z5T8o=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/img/favicon.svg sizes=any><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://joejztang.github.io/>130l
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Posts</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://joejztang.github.io/posts/union-find%E6%80%BB%E7%BB%93/>Union Find总结</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2018-11-22T12:35:47Z>November 22, 2018
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
2-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/alg/>Alg</a></span></div></div></header><div class=post-content><h1 id=什么是-union-find并查集>什么是 union find(并查集)
<a class=heading-link href=#%e4%bb%80%e4%b9%88%e6%98%af-union-find%e5%b9%b6%e6%9f%a5%e9%9b%86><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><blockquote><p>在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题
&mdash; from Wikipedia</p></blockquote><h1 id=union-find-适用于解决什么问题>union find 适用于解决什么问题
<a class=heading-link href=#union-find-%e9%80%82%e7%94%a8%e4%ba%8e%e8%a7%a3%e5%86%b3%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>给出节点, 判断他们是否联通, 并且不需要给出具体路径.</p><p>如果需要判断是否联通, 并且需要给出具体路径, 那么就需要用 BFS 或者 DFS 来解决了.</p><h2 id=union-find-的应用>union find 的应用
<a class=heading-link href=#union-find-%e7%9a%84%e5%ba%94%e7%94%a8><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li>判断网络是否联通</li><li>lc 200, number of islands</li></ul><h1 id=union-find-设计>Union find 设计
<a class=heading-link href=#union-find-%e8%ae%be%e8%ae%a1><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>UF</span><span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// init n sites with integer names (0~n-1)</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>UF(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>n);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// connect p and q</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>union</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>p,<span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>q);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// find component id of p</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>find</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>p);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// return if p and q is connected</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>boolean</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>connected</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>p,<span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>q);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#8b949e;font-style:italic>// number of components</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>count</span>();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p><code>union()</code> 和 <code>connected()</code> 都依赖于 <code>find()</code>, 所以<code>find()</code>要很有效率才行.</p><h1 id=quick-union---union-find-算法的一种实现>quick union - union find 算法的一种实现
<a class=heading-link href=#quick-union---union-find-%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%80%e7%a7%8d%e5%ae%9e%e7%8e%b0><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><h2 id=quick-find-一种比较慢的算法>quick find 一种比较慢的算法
<a class=heading-link href=#quick-find-%e4%b8%80%e7%a7%8d%e6%af%94%e8%be%83%e6%85%a2%e7%9a%84%e7%ae%97%e6%b3%95><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>UF</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>private</span><span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#ff7b72;font-weight:700>[]</span><span style=color:#6e7681> </span>id;<span style=color:#6e7681> </span><span style=color:#8b949e;font-style:italic>// access to component id (site indexed)</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>private</span><span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>count;<span style=color:#6e7681> </span><span style=color:#8b949e;font-style:italic>// number of components</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>UF</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>N)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// Initialize component id array.</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>count<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>N;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>id<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#ff7b72;font-weight:700>[</span>N<span style=color:#ff7b72;font-weight:700>]</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>for</span><span style=color:#6e7681> </span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>i<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>0;<span style=color:#6e7681> </span>i<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#6e7681> </span>N;<span style=color:#6e7681> </span>i<span style=color:#ff7b72;font-weight:700>++</span>)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span>id<span style=color:#ff7b72;font-weight:700>[</span>i<span style=color:#ff7b72;font-weight:700>]</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>i;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>count</span>()<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>{<span style=color:#6e7681> </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>count;<span style=color:#6e7681> </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>boolean</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>connected</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>p,<span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>q)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>{<span style=color:#6e7681> </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>find(p)<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>==</span><span style=color:#6e7681> </span>find(q);<span style=color:#6e7681> </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>find</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>p)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>{<span style=color:#6e7681> </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>id<span style=color:#ff7b72;font-weight:700>[</span>p<span style=color:#ff7b72;font-weight:700>]</span>;<span style=color:#6e7681> </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>union</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>p,<span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>q)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// 获得p和q的组号</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>pID<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>find(p);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>qID<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>find(q);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// 如果两个组号相等，直接返回</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>if</span><span style=color:#6e7681> </span>(pID<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>==</span><span style=color:#6e7681> </span>qID)<span style=color:#6e7681> </span><span style=color:#ff7b72>return</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// 遍历一次，改变组号使他们属于一个组, 这一步消耗巨大</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>for</span><span style=color:#6e7681> </span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>i<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>0;<span style=color:#6e7681> </span>i<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#6e7681> </span>id.length;<span style=color:#6e7681> </span>i<span style=color:#ff7b72;font-weight:700>++</span>)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span><span style=color:#ff7b72>if</span><span style=color:#6e7681> </span>(id<span style=color:#ff7b72;font-weight:700>[</span>i<span style=color:#ff7b72;font-weight:700>]</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>==</span><span style=color:#6e7681> </span>pID)<span style=color:#6e7681> </span>id<span style=color:#ff7b72;font-weight:700>[</span>i<span style=color:#ff7b72;font-weight:700>]</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>qID;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>count<span style=color:#ff7b72;font-weight:700>--</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>如果有 m 个新 union, 那么每次要遍历 n, 那么最后复杂度就成了 mn. 有没有办法不用这么复杂呢?</p><h2 id=quick-union-用树把相同组号的节点组织起来>quick union 用树把相同组号的节点组织起来
<a class=heading-link href=#quick-union-%e7%94%a8%e6%a0%91%e6%8a%8a%e7%9b%b8%e5%90%8c%e7%bb%84%e5%8f%b7%e7%9a%84%e8%8a%82%e7%82%b9%e7%bb%84%e7%bb%87%e8%b5%b7%e6%9d%a5><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>quick union 和 quick find 的的差别就在 find 和 union 上.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>UF</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>private</span><span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#ff7b72;font-weight:700>[]</span><span style=color:#6e7681> </span>id;<span style=color:#6e7681> </span><span style=color:#8b949e;font-style:italic>// access to component id (site indexed)</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>private</span><span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>count;<span style=color:#6e7681> </span><span style=color:#8b949e;font-style:italic>// number of components</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>UF</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>N)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// Initialize component id array.</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>count<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>N;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>id<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#ff7b72>new</span><span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#ff7b72;font-weight:700>[</span>N<span style=color:#ff7b72;font-weight:700>]</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>for</span><span style=color:#6e7681> </span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>i<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>0;<span style=color:#6e7681> </span>i<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#6e7681> </span>N;<span style=color:#6e7681> </span>i<span style=color:#ff7b72;font-weight:700>++</span>)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>      </span>id<span style=color:#ff7b72;font-weight:700>[</span>i<span style=color:#ff7b72;font-weight:700>]</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>i;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>count</span>()<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>{<span style=color:#6e7681> </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>count;<span style=color:#6e7681> </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>boolean</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>connected</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>p,<span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>q)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>{<span style=color:#6e7681> </span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>find(p)<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>==</span><span style=color:#6e7681> </span>find(q);<span style=color:#6e7681> </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>private</span><span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>find</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>p)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  	</span><span style=color:#8b949e;font-style:italic>// 寻找p节点所在组的根节点，根节点具有性质id[root] = root</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  	</span><span style=color:#ff7b72>while</span><span style=color:#6e7681> </span>(p<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>!=</span><span style=color:#6e7681> </span>id<span style=color:#ff7b72;font-weight:700>[</span>p<span style=color:#ff7b72;font-weight:700>]</span>)<span style=color:#6e7681> </span>p<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>id<span style=color:#ff7b72;font-weight:700>[</span>p<span style=color:#ff7b72;font-weight:700>]</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  	</span><span style=color:#ff7b72>return</span><span style=color:#6e7681> </span>p;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>union</span>(<span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>p,<span style=color:#6e7681> </span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>q)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  	</span><span style=color:#8b949e;font-style:italic>// Give p and q the same root.</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  	</span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>pRoot<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>find(p);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  	</span><span style=color:#ff7b72>int</span><span style=color:#6e7681> </span>qRoot<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>find(q);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  	</span><span style=color:#ff7b72>if</span><span style=color:#6e7681> </span>(pRoot<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>==</span><span style=color:#6e7681> </span>qRoot)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  		</span><span style=color:#ff7b72>return</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  	</span>id<span style=color:#ff7b72;font-weight:700>[</span>pRoot<span style=color:#ff7b72;font-weight:700>]</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>qRoot;<span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// 将一颗树(即一个组)变成另外一课树(即一个组)的子树</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  	</span>count<span style=color:#ff7b72;font-weight:700>--</span>;<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><h2 id=更多的优化>更多的优化
<a class=heading-link href=#%e6%9b%b4%e5%a4%9a%e7%9a%84%e4%bc%98%e5%8c%96><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>即使有 quick union, 但是在极端情况下, bst 会变成一个链表, 导致复杂度还是 mn.</p><p>为了克服这个问题, 我们可以把 bst 变成 avl或者红黑树.</p><p>如果树的大小不一样的话, 总把小的树并到大树上.</p><p>等等.</p><p>由于这个总结是为了更好地刷题, 所以想要了解更多, 还请参考原文.</p><h1 id=credit-to>credit to:
<a class=heading-link href=#credit-to><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><ul><li><a href=https://blog.csdn.net/dm_vincent/article/details/7655764 class=external-link target=_blank rel=noopener>https://blog.csdn.net/dm_vincent/article/details/7655764</a></li></ul></div><footer><div class=comments><script>let getTheme=window.localStorage&&window.localStorage.getItem("colorscheme"),themeInParams="github-light";getTheme==null&&(themeInParams!==""&&themeInParams!=="auto"?getTheme=themeInParams:getTheme=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");let theme=getTheme==="dark"?"github-dark":"github-light",s=document.createElement("script");s.src="https://utteranc.es/client.js",s.setAttribute("repo","joejztang/joejztang.github.io"),s.setAttribute("issue-term","pathname"),s.setAttribute("theme",theme),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></footer></article></section></div><footer class=footer><section class=container>©
1990 -
2025
130l
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-YNPYVVT1S7"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-YNPYVVT1S7")}</script></body></html>