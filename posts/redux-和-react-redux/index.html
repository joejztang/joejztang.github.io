<!doctype html><html lang=en><head><title>redux 和 react-redux · 130l</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="130l"><meta name=description content="
  Flux
  
    
    Link to heading
  

首先我们回顾一下 flux 的模式


Flux的核心思想就是 数据和逻辑永远单向流动

  redux
  
    
    Link to heading
  

redux 借鉴了很多 flux 里的概念, 只是略有不同. redux 也是一种模式的设计.

  
      
          Flux
          Redux
      
  
  
      
          多个 store
          一个 store
      
      
          dispatcher对 store 进行修改
          没有 dispatcher这个概念. 它使用 reducer 进行事件的处理. reducer 是纯函数.
      
  


  createStore
  
    
    Link to heading
  

抽象出来一个 createStore, 它可以产生 store, 里面包含 getState 和 dispatch. 发现每次都要重复的渲染所有组件, 我们引入观察者模式, 加入 subscriber 和 listener, 把渲染这个 object(实际是函数) 压到 listener 的array 里."><meta name=keywords content="blog,science,technology,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="redux 和 react-redux"><meta name=twitter:description content="Flux Link to heading 首先我们回顾一下 flux 的模式
Flux的核心思想就是 数据和逻辑永远单向流动
redux Link to heading redux 借鉴了很多 flux 里的概念, 只是略有不同. redux 也是一种模式的设计.
Flux Redux 多个 store 一个 store dispatcher对 store 进行修改 没有 dispatcher这个概念. 它使用 reducer 进行事件的处理. reducer 是纯函数. createStore Link to heading 抽象出来一个 createStore, 它可以产生 store, 里面包含 getState 和 dispatch. 发现每次都要重复的渲染所有组件, 我们引入观察者模式, 加入 subscriber 和 listener, 把渲染这个 object(实际是函数) 压到 listener 的array 里."><meta property="og:url" content="http://www.example.com/posts/redux-%E5%92%8C-react-redux/"><meta property="og:site_name" content="130l"><meta property="og:title" content="redux 和 react-redux"><meta property="og:description" content="Flux Link to heading 首先我们回顾一下 flux 的模式
Flux的核心思想就是 数据和逻辑永远单向流动
redux Link to heading redux 借鉴了很多 flux 里的概念, 只是略有不同. redux 也是一种模式的设计.
Flux Redux 多个 store 一个 store dispatcher对 store 进行修改 没有 dispatcher这个概念. 它使用 reducer 进行事件的处理. reducer 是纯函数. createStore Link to heading 抽象出来一个 createStore, 它可以产生 store, 里面包含 getState 和 dispatch. 发现每次都要重复的渲染所有组件, 我们引入观察者模式, 加入 subscriber 和 listener, 把渲染这个 object(实际是函数) 压到 listener 的array 里."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-09-05T14:20:02+00:00"><meta property="article:modified_time" content="2018-09-05T14:20:02+00:00"><meta property="article:tag" content="React"><meta property="article:tag" content="Redux"><link rel=canonical href=http://www.example.com/posts/redux-%E5%92%8C-react-redux/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.4b392a85107b91dbdabc528edf014a6ab1a30cd44cafcd5325c8efe796794fca.css integrity="sha256-SzkqhRB7kdvavFKO3wFKarGjDNRMr81TJcjv55Z5T8o=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/img/favicon.svg sizes=any><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=http://www.example.com/>130l
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Posts</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=http://www.example.com/posts/redux-%E5%92%8C-react-redux/>redux 和 react-redux</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2018-09-05T14:20:02Z>September 5, 2018
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
One-minute read</span></div><div class=categories><i class="fa-solid fa-folder" aria-hidden=true></i>
<a href=/categories/javascript/>Javascript</a></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/react/>React</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/redux/>Redux</a></span></div></div></header><div class=post-content><h1 id=flux>Flux
<a class=heading-link href=#flux><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>首先我们回顾一下 flux 的模式</p><p><img src=/images/flux.png alt=flux></p><blockquote><p>Flux的核心思想就是 <strong>数据和逻辑永远单向流动</strong></p></blockquote><h1 id=redux>redux
<a class=heading-link href=#redux><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>redux 借鉴了很多 flux 里的概念, 只是略有不同. redux 也是一种模式的设计.</p><table><thead><tr><th>Flux</th><th>Redux</th></tr></thead><tbody><tr><td>多个 store</td><td>一个 store</td></tr><tr><td>dispatcher对 store 进行修改</td><td>没有 dispatcher这个概念. 它使用 reducer 进行事件的处理. reducer 是纯函数.</td></tr></tbody></table><h1 id=createstore>createStore
<a class=heading-link href=#createstore><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>抽象出来一个 <code>createStore</code>, 它可以产生 <code>store</code>, 里面包含 <code>getState</code> 和 <code>dispatch</code>. 发现每次都要重复的渲染所有组件, 我们引入观察者模式, 加入 <code>subscriber</code> 和 <code>listener</code>, 把渲染这个 object(实际是函数) 压到 <code>listener</code> 的array 里.</p><h1 id=共享结构对象>共享结构对象
<a class=heading-link href=#%e5%85%b1%e4%ba%ab%e7%bb%93%e6%9e%84%e5%af%b9%e8%b1%a1><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>共享结构对象的实质就是简单的在渲染开头判断有没有修改数据, 如果修改过数据才渲染, 不然不渲染.</p><h1 id=reducer>reducer
<a class=heading-link href=#reducer><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>reducer 也可以叫做 <code>stateChanger</code>, 目的是初始化 state 或者根据 <code>oldState</code> 和 <code>action</code> 计算新的 <code>newState</code>. 这样做就相当于大张旗鼓的告诉大家我要修改 state 了, 从而做到了每个 action 都会在系统中留下一笔的效果.</p><h1 id=一个简单的套路结构>一个简单的套路结构
<a class=heading-link href=#%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84%e5%a5%97%e8%b7%af%e7%bb%93%e6%9e%84><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 定一个 reducer
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>function</span> reducer (state, action) {
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>/* 初始化 state 和 switch case */</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 生成 store
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>const</span> store <span style=color:#ff7b72;font-weight:700>=</span> createStore(reducer)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 监听数据变化重新渲染页面
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>store.subscribe(() =&gt; renderApp(store.getState()))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 首次渲染页面
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>renderApp(store.getState())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 后面可以随意 dispatch 了，页面自动更新
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>store.dispatch(...)
</span></span></code></pre></div><h1 id=credit-to>credit to
<a class=heading-link href=#credit-to><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><ul><li><a href=https://www.jianshu.com/p/79f414053384 class=external-link target=_blank rel=noopener>flux模式架构</a></li><li><a href=http://huziketang.mangojuice.top/books/react/lesson35 class=external-link target=_blank rel=noopener>react 小书</a></li></ul></div><footer></footer></article></section></div><footer class=footer><section class=container>©
1990 -
2025
130l
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>