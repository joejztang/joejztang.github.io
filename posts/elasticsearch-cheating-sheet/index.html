<!doctype html><html lang=en><head><title>elasticsearch cheating sheet · 130l</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="130l"><meta name=description content="
  concepts
  
    
    Link to heading
  


cluster: a collection of nodes
node: part to store data
index: a collection of similar documents
type: a category or a partition of indexes
document: json formated data
shard/replica: shard of a portion of indexes, whereas replica is a segment of an index.



  roles of node
  
    
    Link to heading
  


master
data
ingest: it somewhat like simplified logstash
ml

by default, it&rsquo;s dim permission. for different size of cluster, especially medium and large size, we could have dedicated master nodes."><meta name=keywords content="blog,science,technology,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="elasticsearch cheating sheet"><meta name=twitter:description content="concepts Link to heading cluster: a collection of nodes node: part to store data index: a collection of similar documents type: a category or a partition of indexes document: json formated data shard/replica: shard of a portion of indexes, whereas replica is a segment of an index. roles of node Link to heading master data ingest: it somewhat like simplified logstash ml by default, it’s dim permission. for different size of cluster, especially medium and large size, we could have dedicated master nodes."><meta property="og:url" content="http://www.example.com/posts/elasticsearch-cheating-sheet/"><meta property="og:site_name" content="130l"><meta property="og:title" content="elasticsearch cheating sheet"><meta property="og:description" content="concepts Link to heading cluster: a collection of nodes node: part to store data index: a collection of similar documents type: a category or a partition of indexes document: json formated data shard/replica: shard of a portion of indexes, whereas replica is a segment of an index. roles of node Link to heading master data ingest: it somewhat like simplified logstash ml by default, it’s dim permission. for different size of cluster, especially medium and large size, we could have dedicated master nodes."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-01T14:03:03+00:00"><meta property="article:modified_time" content="2019-10-01T14:03:03+00:00"><meta property="article:tag" content="Cheating Sheet"><link rel=canonical href=http://www.example.com/posts/elasticsearch-cheating-sheet/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.4b392a85107b91dbdabc528edf014a6ab1a30cd44cafcd5325c8efe796794fca.css integrity="sha256-SzkqhRB7kdvavFKO3wFKarGjDNRMr81TJcjv55Z5T8o=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/img/favicon.svg sizes=any><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=http://www.example.com/>130l
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Posts</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=http://www.example.com/posts/elasticsearch-cheating-sheet/>elasticsearch cheating sheet</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2019-10-01T14:03:03Z>October 1, 2019
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
10-minute read</span></div><div class=categories><i class="fa-solid fa-folder" aria-hidden=true></i>
<a href=/categories/elasticsearch/>Elasticsearch</a></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/cheating-sheet/>Cheating Sheet</a></span></div></div></header><div class=post-content><h2 id=concepts>concepts
<a class=heading-link href=#concepts><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li>cluster: a collection of nodes</li><li>node: part to store data</li><li>index: a collection of similar documents</li><li>type: a category or a partition of indexes</li><li>document: json formated data</li><li>shard/replica: shard of a <strong>portion</strong> of indexes, whereas replica is a segment of an index.</li></ul><p><img src=/images/visual-es-concepts.PNG alt="concepts visual"></p><h2 id=roles-of-node>roles of node
<a class=heading-link href=#roles-of-node><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li>master</li><li>data</li><li>ingest: it somewhat like simplified <code>logstash</code></li><li>ml</li></ul><p>by default, it&rsquo;s <code>dim</code> permission. for different size of cluster, especially medium and large size, we could have dedicated master nodes.</p><p>don&rsquo;t changes roles unless you fully understand what you are doing.</p><h2 id=easy-crud-operations>easy CRUD operations
<a class=heading-link href=#easy-crud-operations><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><code>&lt;REST verb> &lt;index> &lt;type> &lt;id></code></p><p>for example: <code>GET _cat/model?v</code> or <code>GET _cat/indices?v</code></p><p><em>above is getting information out of elasticsearch</em></p><p>or</p><pre tabindex=0><code>PUT /sales/order/123
{
    &#34;orderID&#34;: &#34;123&#34;,
    &#34;orderAmount&#34;: &#34;500&#34;
}
</code></pre><p><em>creating documents</em></p><p>it&rsquo;s best practice to create indices first and then add documents.</p><p>or</p><pre tabindex=0><code>POST /sales/_update/123
{
    &#34;doc&#34;: {
        &#34;orderID&#34;: 1234
    }
}
</code></pre><p><em>this update a document</em></p><h3 id=scripted-update>scripted update
<a class=heading-link href=#scripted-update><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><pre tabindex=0><code>POST /products/_update/123
{
    &#34;script&#34;: {
        &#34;source&#34;: &#34;ctx._source.in_stock -= params.quantity&#34;,
        &#34;params&#34;: {
            &#34;quantity&#34;: 4
        }
    }
}
</code></pre><p><em>ctx is short of context</em></p><p>there are even more complicated scripts</p><p>you can insert if conditions diverting operations.</p><pre tabindex=0><code>POST /products/_update/123
{
    &#34;script&#34;: {
        &#34;source&#34; : &#34;&#34;&#34;
            if (ctx._source.in_stock == 0) {
                ctx.op = &#39;noop&#39;;
            }

            ctx._source.in_stock--;
        &#34;&#34;&#34;
    }
}
</code></pre><h2 id=bonus-information>bonus information
<a class=heading-link href=#bonus-information><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=reading-documents--routing>reading documents &ndash; routing
<a class=heading-link href=#reading-documents--routing><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>how does elaticsearch know which shard to store documents? how are documents found once they have been indexed?</p><p>elasticsearch uses routing mechanism to search documents.</p><p><code>shard_num = hash(_routing) % num_primary_shards</code></p><p>as you can see, in the equation there is a parameter called <code>num_primary_shards</code>, and remember we say once shards been created, it cannot be changed. one has to use <code>shrink</code> or <code>split</code> api to reindex to make sure old documents are searchable.</p><h3 id=writing-doucments--primary-term-and-checkpoints>writing doucments &ndash; primary term and checkpoints
<a class=heading-link href=#writing-doucments--primary-term-and-checkpoints><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><code>primary terms</code> is a counter for how many times the primary shards has changed (writing operations).</p><p><code>sequence numbers</code> is a counter that being incremented for each write operation. note that primary shards increases the sequence number.</p><p>as for checkpoints</p><p>each replication group has a <code>global checkpoint</code> and each replica shard has a <code>local checkpoint</code></p><p><code>global checkpoints</code> is the sequence number that all shards within the replication group has been applied at least up to</p><p><code>local checkpoints</code> is the last write operation that was performed.</p><p><strong>checkpoints are essentially sequence numbers</strong></p><p>given above information, we could imply when network failing:</p><ul><li><p>when primary shards failed and wants to rejoin, it will just compare with <code>global checkpoint</code> and apply the operations later than <code>global checkpoints</code></p></li><li><p>when replica shards failed and wants to rejoin, it will only compare with <code>local checkpoint</code> and only higher number will rejoin.</p></li></ul><h2 id=bulk-api>bulk api
<a class=heading-link href=#bulk-api><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>when writes many at the same time, we want to use <code>/_bulk</code> API</p><p>under <code>/_bulk</code></p><p>in terminal, we do</p><p><code>curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/&lt;index>/&lt;type>/_bulk?pretty --data-binary "@&lt;json_file_name>"; echo</code></p><p>for the file &ldquo;@&lt;json_file_name>&rdquo;, there must be an empty line at the end of the file.</p><p>in Kibana</p><p><code>POST /_bulk { &lt;action> } { &lt;document> }</code></p><h2 id=data-types>data types
<a class=heading-link href=#data-types><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li>core data type: text, numric, boolean, binary</li><li>complex: array, object</li><li>geo: geo_point, geo_shape</li><li>specialized: ip addr, token</li></ul><h2 id=meta-fields>meta fields
<a class=heading-link href=#meta-fields><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li>_index: name of the index</li><li>_id: id</li><li>_source: original json object used when indexing a document</li><li>_field_names</li><li>_routing</li><li>_version</li><li>_meta</li></ul><h2 id=mappings>mappings
<a class=heading-link href=#mappings><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>for simple use of elasticsearch, mappings are rarely used. but using mappings can control elasticsearch concisely.</p><p>or just trust dynamic mapping is good enough.</p><h2 id=analyzers>analyzers
<a class=heading-link href=#analyzers><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>once we index a document, elasticsearch will run the whole analyze process. when later we search, we are not searching the document; we are searching the <code>inverted index</code>.</p><p>analyzer consists of (sequential order):</p><ul><li>character filters: to manipulate text before tokenization. like taking out some mark up language such as html, defaults are:<ul><li>html strip filter</li><li>mapping character filter</li><li>pattern replace</li></ul></li><li>tokenizer: chop words into term. i.e. do some logic on top of tokens, like lower the case, etc. 3 main categories are:<ul><li>word oriented tokenizers<ul><li>standard tokenizer (<code>standard</code>)</li><li>letter tokenizer (<code>letter</code>)</li><li>lowercase tokenizer (<code>lowercase</code>)</li><li>whitespace tokenizer (<code>whitespace</code>)</li><li>uax url email tokenizer (<code>uax_url_email</code>)</li></ul></li><li>partial word tokenizers<ul><li>N-Gram tokenizer (<code>ngram</code>): &ldquo;red wine&rdquo; -> [re, red, ed, wi, win, wine, in, ine, ne]</li><li>edge N-Gram tokenizer (<code>edge_ngram</code>)</li></ul></li><li>structured text tokenizers<ul><li>keyword tokenizer (<code>keyword</code>)</li><li>pattern tokenizer (<code>pattern</code>)</li><li>path tokenizer (<code>path_hierarchy</code>)</li></ul></li></ul></li><li>token filters: get rid of some white spaces, comma, etc<ul><li><code>stardard</code></li><li><code>lowercase</code></li><li><code>uppercase</code></li><li><code>nGram</code></li><li><code>edgeNGram</code></li><li><code>stop</code></li><li><code>word_delimiter</code></li><li><code>stemmer</code></li><li><code>keyword_marker</code></li><li><code>snowball</code></li><li><code>synonym</code></li></ul></li></ul><p><em>standard analyzer doesn&rsquo;t contain a character filter</em></p><ul><li><p>analyzers by default:</p><ul><li><code>simple analyzer</code></li><li><code>stop analyzer</code></li><li><code>language analyzer</code></li><li><code>keyword analyzer</code></li><li><code>pattern analyzer</code></li><li><code>whitespace analyzer</code></li></ul></li><li><p>customizing analyzers</p></li></ul><p>heirachy: <code>settings -> analysis -> analyzer/filter/......</code></p><p>analyzer can be also created by our own. with in analyzer block, we need to give <code>tokenizer, char_filter, token filter(s)</code></p><p>previously, people remove stop words before analyze. but with the development of search algorithm, we don&rsquo;t need to remove stop words anymore because search algorithm will handle stop words pretty well.</p><h3 id=inverted-index--an-index-data-structure-storing-a-mapping-from-content-to-index>inverted index : an index data structure storing a mapping from content to index.
<a class=heading-link href=#inverted-index--an-index-data-structure-storing-a-mapping-from-content-to-index><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><blockquote><p>there are two types of <code>inverted index</code>, a <code>record-level inverted index</code> and a <code>word-level inverted index</code>.</p></blockquote><p>the latter form asked for more processing power and space.</p><p>a concrete example</p><blockquote><p>Suppose we want to search the texts &ldquo;hello everyone, " &ldquo;this article is based on inverted index, " &ldquo;which is hashmap like data structure&rdquo;. If we index by (text, word within the text), the index with location in text is:</p></blockquote><pre tabindex=0><code> hello                (1, 1)
 everyone             (1, 2)
 this                 (2, 1)
 article              (2, 2)
 is                   (2, 3); (3, 2)
 based                (2, 4)
 on                   (2, 5)
 inverted             (2, 6)
 index                (2, 7)
 which                (3, 1)
 hashmap              (3, 3)
 like                 (3, 4)
 data                 (3, 5)
 structure            (3, 6)
</code></pre><h2 id=querysearch>query/search
<a class=heading-link href=#querysearch><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>elasticsearch uses query DSL, a query based on JSON</p><h3 id=query-dsl>query DSL
<a class=heading-link href=#query-dsl><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li>Leaf Query: search values in particular field</li><li>Compound Query: contains multiple leaf queries or compound queries themselves</li></ul><h3 id=algorithm-using-behind-_score>algorithm using behind <code>_score</code>
<a class=heading-link href=#algorithm-using-behind-_score><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>elasticsearch previously used <code>TF/IDF</code>, but now it uses <code>BM25</code>. in general, they are similar, but there are still slight differences. because similarities in general, we will discuss <code>TF/IDF</code> anyways.</p><ul><li>term frequency <code>TF</code>: it looks how many times the term appear in a given DOCUMENT. the more it appears, the more important</li><li>inverse document frequency <code>IDF</code>: how often does the term appear in INDEX (all documents). the more it appears, the less important</li></ul><p><code>TF/IDF</code> formula is w(i, j) = tf(i, j) x log(N/df(i)) where</p><p>tf(i, j) is number of occurrences of i in j</p><p>df(i) is number of documents containing i</p><p>N is total number of documents</p><ul><li>a third factor to consider: field length norm</li></ul><p>meaning how long the field is. if the term appear in a field with length 50, then it&rsquo;s more important than the same appearing in a field with length 5000.</p><h2 id=query-context-and-filter-context>query context and filter context
<a class=heading-link href=#query-context-and-filter-context><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li>query context will calculate relevance score</li><li>filter context do a boolean evaluation, it&rsquo;s either a match or not.</li></ul><h2 id=term-level-and-full-text-query>term level and full text query
<a class=heading-link href=#term-level-and-full-text-query><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>term level query doesn&rsquo;t do analyzing, it searches in inverted index.</p><p>full text query search analyzed text fields. meaning it will analyze first.</p><h3 id=one-condition>one condition
<a class=heading-link href=#one-condition><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>match all query
<code>GET bank/account/_search</code></p><p>or</p><pre tabindex=0><code>GET bank/account/_search
{
    &#34;query&#34;: {
        &#34;match&#34;: {
            &#34;state&#34;: &#34;CA&#34;
        }
    }
}
</code></pre><p><em>remember match with analyze text first</em></p><h3 id=multi-conditions>multi conditions
<a class=heading-link href=#multi-conditions><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><pre tabindex=0><code>GET bank/account/_search
{
    &#34;query&#34;: {
        &#34;bool&#34;: {
            &#34;must/must_not&#34;: [
                {&#34;match&#34;: {
                    //match condition 1
                }},
                {&#34;match&#34;: {
                    //match condition 2
                }}
            ]
        }
    }
}
</code></pre><p><em>this is more like a bool query</em></p><p>bool query usually used for multiple queries</p><h3 id=boost>boost
<a class=heading-link href=#boost><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>key word <code>boost</code> is to boost the document to the front, in another word, making the document higher priority.</p><p><code>boost</code> works with <code>should</code></p><p>example:</p><pre tabindex=0><code>GET bank/account/_search
{
    &#34;query&#34;: {
        &#34;bool&#34;: {
            &#34;should&#34;: [
                {&#34;match&#34;: {&#34;state&#34;: &#34;CA&#34;}},
                {&#34;match&#34;: {&#34;lastname&#34;: {&#34;query&#34;: &#34;Smith&#34;, &#34;boost&#34;: 3}}}
            ]
        }
    }
}
</code></pre><p>the above query will boost field lastname, it will affect <code>_score</code></p><h3 id=term-level-query>term-level query
<a class=heading-link href=#term-level-query><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><code>term</code> only works with keywords and numeric values, will not work with text field</p><p><code>terms</code> can query multiple input</p><p><code>range</code> will query with <code>gte</code> and <code>lte</code>, searching in that range</p><p>example:</p><pre tabindex=0><code>GET bank/account/_search
{
    &#34;query&#34;: {
        &#34;range&#34;: {
            &#34;account_number&#34;: {
                &#34;gte&#34;: 516,
                &#34;lte&#34;: 851,
                &#34;boost&#34;: 2
            }
        }
    }
}
</code></pre><h2 id=joining-queries>joining queries
<a class=heading-link href=#joining-queries><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>in theory, in elaticsearch, or all key-value pair storage, it&rsquo;s not like relational db has primary keys and foriegn keys.</p><p>the idea &lsquo;join&rsquo; is usually completed in application level.</p><h3 id=nested-inner-hits>nested inner hits
<a class=heading-link href=#nested-inner-hits><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><code>inner hits</code> is a option of <code>nested</code>, will tell insights which hits object are comming from</p><h3 id=join_field>join_field
<a class=heading-link href=#join_field><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>define parent child relations or define which side this document belongs to, parent or child.</p><p>parent and child documents have to be in the same shard. so we have to provide routing id.</p><h3 id=has_parent-has_child>has_parent, has_child
<a class=heading-link href=#has_parent-has_child><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><h2 id=analysis-and-tokenization>analysis and tokenization
<a class=heading-link href=#analysis-and-tokenization><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><code>analyze</code> endpoint will analyze the the <code>text</code>, and give the token.</p><p>example</p><pre tabindex=0><code>GET bank/_analyze
{
    &#34;tokenizer&#34;: &#34;standard&#34;,
    &#34;text&#34;: &#34;The Moon is Made of Cheese someone say&#34;
}
</code></pre><p>here <code>tokenizer</code> works like a <code>delimiter</code></p><p>there is also one keyword called <code>analyzer</code>, which will direct es what to do with the field, for example: <code>standard</code> analyzer will lower case all text whereas <code>english</code> analyzer will delete plural form.</p><h2 id=analyze-data>analyze data
<a class=heading-link href=#analyze-data><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=aggregation>aggregation
<a class=heading-link href=#aggregation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><code>aggs</code> means aggregation. <code>aggs</code> can be nested into another <code>aggs</code></p><p>very complicated example:</p><pre tabindex=0><code>GET bank/account/_search
{
    &#34;size&#34;: 0,
    &#34;aggs&#34;: {
        &#34;states&#34;: {
            &#34;terms&#34;: {
                &#34;field&#34;: &#34;state.keyword&#34;
            },
            &#34;aggs&#34;: {
                &#34;avg_bal&#34;: {
                    &#34;avg&#34;: { &#34;field&#34;: &#34;balance&#34; }
                },
                &#34;gender&#34;: {
                    &#34;terms&#34;: { &#34;field&#34;: &#34;gender.keyword&#34; }
                },
                &#34;aggs&#34;: {&#34;avg_bal&#34;: {&#34;avg&#34;: { &#34;field&#34;: &#34;balance&#34; }}}
            }
        }
    }
}
</code></pre><p><code>stats</code> is very useful as well.</p><h3 id=filter-aggregation>filter aggregation
<a class=heading-link href=#filter-aggregation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>one way doing it is before <code>aggs</code>, using <code>query</code> to filter.</p><pre tabindex=0><code>GET bank/account/_search
{
    &#34;size&#34;: 0,
    &#34;query&#34;: {
        &#34;match&#34;: {&#34;state.keyword&#34;: &#34;CA&#34;}
    },
    &#34;aggs&#34;: {
        &#34;states&#34;: {
            &#34;terms&#34;: {
                &#34;field&#34;: &#34;state.keyword&#34;
            },
            &#34;aggs&#34;: {
                &#34;avg_bal&#34;: {
                    &#34;avg&#34;: { &#34;field&#34;: &#34;balance&#34; }
                },
                &#34;gender&#34;: {
                    &#34;terms&#34;: { &#34;field&#34;: &#34;gender.keyword&#34; }
                },
                &#34;aggs&#34;: {&#34;avg_bal&#34;: {&#34;avg&#34;: { &#34;field&#34;: &#34;balance&#34; }}}
            }
        }
    }
}
</code></pre><p>another way is using <code>filter</code> keyword</p><pre tabindex=0><code>GET bank/account/_search
{
    &#34;size&#34;: 0,
    &#34;query&#34;: {
        &#34;match&#34;: {&#34;state.keyword&#34;: &#34;CA&#34;}
    },
    &#34;aggs&#34;: {
        &#34;over35&#34;: {
            &#34;filter&#34;: {
                &#34;range&#34;: {&#34;age&#34;: {&#34;gt&#34;: 35}}
            }
        },
        &#34;aggs&#34;: {&#34;avg_bal&#34;: {&#34;avg&#34;: {&#34;field&#34;: &#34;balance&#34;}}}
    }
}
</code></pre><p>using <code>filter</code>, we can filter in aggreation level (inside aggragation).</p><h3 id=metrics-aggregation>metrics aggregation
<a class=heading-link href=#metrics-aggregation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><pre tabindex=0><code>&#34;aggs&#34; : {
    &#34;FIELD&#34; : {
        &#34;AGG_TYPE&#34; : { &#34;field&#34;: &#34;xxxxxx&#34; }
    }
}
</code></pre><p><code>AGG_TYPE</code> could be</p><ul><li>sum</li><li>avg</li><li>min</li><li>max</li><li>cardinality</li><li>value_count</li><li>amount_stats</li></ul><h3 id=bucket-aggregation>bucket aggregation
<a class=heading-link href=#bucket-aggregation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>bucket aggregation will create bucket for each unique value according to criteria.</p><p>term aggretion</p><p>aggregation can be nested in aggregations</p><p>the outer layer of aggregation is queried in context of query, and inner aggregation is queried in context of aggregated/filtered context.</p><p><code>global aggregation</code> can be only placed on top level of the query.</p><p><code>nested aggregation</code> can be used doing fancier queries</p><h2 id=improve-searches>improve searches
<a class=heading-link href=#improve-searches><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=proximity>proximity
<a class=heading-link href=#proximity><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>using <code>slop</code>, meaning how far allowed of terms (edit) distances (despite terms order)</p><p>proximity affects relevances scores</p><p><em>consider <code>must</code> working with <code>should</code> in <code>bool query</code></em></p><h3 id=fuzziness>fuzziness
<a class=heading-link href=#fuzziness><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>using levenstien distances behind the scene</p><p>operating on term level</p><p>fuzziness also introduce <code>transipositions</code></p><h3 id=synonyms>synonyms
<a class=heading-link href=#synonyms><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>use <code>POST /synonyms/_update_by_query</code> to update synonyms, or the documents wouldn&rsquo;t be re indexed.</p><h3 id=highlight>highlight
<a class=heading-link href=#highlight><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>we can use <code>highlight</code> to highlight matches.</p><h3 id=stemming>stemming
<a class=heading-link href=#stemming><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><h2 id=percentiles-and-histagram>percentiles and histagram
<a class=heading-link href=#percentiles-and-histagram><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>keywords: <code>percentiles</code>, <code>hdr</code>, <code>percentile_ranks</code>, <code>histagram</code></p><p>they are helping to understand the distribution of data inside es.</p><h2 id=visualization>visualization
<a class=heading-link href=#visualization><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>create visualization first and then use those &lsquo;modules&rsquo; to dashboard.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
1990 -
2025
130l
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>