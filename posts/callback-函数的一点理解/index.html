<!doctype html><html lang=en><head><title>callback 函数的一点理解 · 130l</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="130l"><meta name=description content="
  什么是 callback
  
    
    Link to heading
  


A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.

  callback 函数执行过程的想象
  
    
    Link to heading
  


所谓的回调函数处理逻辑，其实就是先将回调函数的代码 冻结（或者理解为闲置），接着将这个回调函数的代码放到 回调函数管理器的队列 里面。
待回调函数被触发调用的时候，对应的回调函数的代码才会从管理器队列 取出来并自动执行（激活回调函数的代码），实现异步的编程效果。

  一个小问题
  
    
    Link to heading
  

如同上面的引用说的, callback 被触发, 那么回调函数代码会被从队列里面 pull 出来, 自动执行/激活."><meta name=keywords content="blog,science,technology,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="callback 函数的一点理解"><meta name=twitter:description content="什么是 callback Link to heading A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.
callback 函数执行过程的想象 Link to heading 所谓的回调函数处理逻辑，其实就是先将回调函数的代码 冻结（或者理解为闲置），接着将这个回调函数的代码放到 回调函数管理器的队列 里面。 待回调函数被触发调用的时候，对应的回调函数的代码才会从管理器队列 取出来并自动执行（激活回调函数的代码），实现异步的编程效果。
一个小问题 Link to heading 如同上面的引用说的, callback 被触发, 那么回调函数代码会被从队列里面 pull 出来, 自动执行/激活."><meta property="og:url" content="https://joejztang.github.io/posts/callback-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/"><meta property="og:site_name" content="130l"><meta property="og:title" content="callback 函数的一点理解"><meta property="og:description" content="什么是 callback Link to heading A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.
callback 函数执行过程的想象 Link to heading 所谓的回调函数处理逻辑，其实就是先将回调函数的代码 冻结（或者理解为闲置），接着将这个回调函数的代码放到 回调函数管理器的队列 里面。 待回调函数被触发调用的时候，对应的回调函数的代码才会从管理器队列 取出来并自动执行（激活回调函数的代码），实现异步的编程效果。
一个小问题 Link to heading 如同上面的引用说的, callback 被触发, 那么回调函数代码会被从队列里面 pull 出来, 自动执行/激活."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-08-28T15:29:16+00:00"><meta property="article:modified_time" content="2018-08-28T15:29:16+00:00"><link rel=canonical href=https://joejztang.github.io/posts/callback-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.4b392a85107b91dbdabc528edf014a6ab1a30cd44cafcd5325c8efe796794fca.css integrity="sha256-SzkqhRB7kdvavFKO3wFKarGjDNRMr81TJcjv55Z5T8o=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/img/favicon.svg sizes=any><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://joejztang.github.io/>130l
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Posts</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://joejztang.github.io/posts/callback-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/>callback 函数的一点理解</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2018-08-28T15:29:16Z>August 28, 2018
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
2-minute read</span></div><div class=categories><i class="fa-solid fa-folder" aria-hidden=true></i>
<a href=/categories/javascript/>Javascript</a></div></div></header><div class=post-content><h1 id=什么是-callback>什么是 callback
<a class=heading-link href=#%e4%bb%80%e4%b9%88%e6%98%af-callback><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><blockquote><p>A callback function is a <strong>function</strong> passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.</p></blockquote><h1 id=callback-函数执行过程的想象>callback 函数执行过程的想象
<a class=heading-link href=#callback-%e5%87%bd%e6%95%b0%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b%e7%9a%84%e6%83%b3%e8%b1%a1><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><blockquote><p>所谓的回调函数处理逻辑，其实就是先将回调函数的代码 冻结（或者理解为闲置），接着将这个回调函数的代码放到 <strong>回调函数管理器的队列</strong> 里面。
待回调函数被触发调用的时候，对应的回调函数的代码才会从管理器队列 <strong>取出来并自动执行</strong>（激活回调函数的代码），实现异步的编程效果。</p></blockquote><h1 id=一个小问题>一个小问题
<a class=heading-link href=#%e4%b8%80%e4%b8%aa%e5%b0%8f%e9%97%ae%e9%a2%98><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>如同上面的引用说的, callback 被触发, 那么回调函数代码会被从队列里面 pull 出来, 自动执行/激活.</p><p>但是如果回调函数的代码返回的还是回调函数, 也就是说所谓 callback hell 的情况它会不会一路执行到底呢? 还是说就执行一层然后返回新的回调呢? 我特意做了一个实验</p><h2 id=实验代码>实验代码
<a class=heading-link href=#%e5%ae%9e%e9%aa%8c%e4%bb%a3%e7%a0%81><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#ff7b72>function</span> levelOne(f) {
</span></span><span style=display:flex><span>	console.log(<span style=color:#a5d6ff>&#39;print one time\n&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>return</span> <span style=color:#ff7b72>function</span>(x) {
</span></span><span style=display:flex><span>  	<span style=color:#ff7b72>return</span> f(x);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>var</span> level <span style=color:#ff7b72;font-weight:700>=</span> levelOne(levelOne);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>var</span> wrapper <span style=color:#ff7b72;font-weight:700>=</span> level;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>wrapper();
</span></span></code></pre></div><p>如果说它是一层的, 那么结果应该是打出一次<code>print one time</code>. 如果一路执行到底, 那么应该打出来两次.</p><h2 id=实验结果>实验结果
<a class=heading-link href=#%e5%ae%9e%e9%aa%8c%e7%bb%93%e6%9e%9c><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><pre tabindex=0><code>print one time
print one time
print one time
</code></pre><h2 id=小结>小结
<a class=heading-link href=#%e5%b0%8f%e7%bb%93><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>像是 callback hell 这种情况下, 只要触发了最外一层 callback 函数, 那么 callback 会 <strong>链式</strong> 的一直执行到底.
机制原因 <strong>未知</strong>.</p><p><a href=https://blog.csdn.net/samt007/article/details/54647361 class=external-link target=_blank rel=noopener>这篇文章</a>的作者把这个链式的 callback 称为 <em>嵌套回调</em>.</p><h1 id=再来回看廖大神的阿隆索邱琪的例子>再来回看廖大神的阿隆索邱琪的例子
<a class=heading-link href=#%e5%86%8d%e6%9d%a5%e5%9b%9e%e7%9c%8b%e5%bb%96%e5%a4%a7%e7%a5%9e%e7%9a%84%e9%98%bf%e9%9a%86%e7%b4%a2%e9%82%b1%e7%90%aa%e7%9a%84%e4%be%8b%e5%ad%90><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>我们现在只单单看他的<code>zero</code> 和 <code>one</code> 的定义, 看看我们对回调函数理解有没有好一点.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 定义数字0:
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>var</span> zero <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>function</span> (f) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#ff7b72>function</span> (x) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> x;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 定义数字1:
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>var</span> one <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>function</span> (f) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#ff7b72>function</span> (x) {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> f(x);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>我们发现当 zero() 被执行的时候(盯紧 <code>f</code> 来看), 它的 <code>f</code> 被执行了0次.</p><p>当 one() 被执行的时候, 它的 <code>f</code> 被执行了1次.</p><p>那么依次类推, two 的定义我们就能写出来了</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#ff7b72>var</span> two <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>function</span>(f) {
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>return</span> <span style=color:#ff7b72>function</span>(x) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> f(f(x));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>how about three?</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#ff7b72>var</span> three <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>function</span>(f) {
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>return</span> <span style=color:#ff7b72>function</span>(x) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> f(f(f(x)));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种定义来说, 一旦最外层回调函数被触发, 那么它会链式的一直执行下去. 所以说实际上 <code>f</code> 执行了几次, 它就是几.</p><h1 id=小结-1>小结
<a class=heading-link href=#%e5%b0%8f%e7%bb%93-1><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>本来以为 callback 看懂了, 最近看 react 的东西, 发现 callback 还是不懂, 而且 callback 貌似异常重要, 所以在此记录一下.</p><h1 id=credit-to>credit to
<a class=heading-link href=#credit-to><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><ul><li><a href=https://blog.csdn.net/samt007/article/details/54647361 class=external-link target=_blank rel=noopener>关于js的callback回调函数以及嵌套回调函数的执行过程理解</a></li><li><a href=https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449934543461c9d5dfeeb848f5b72bd012e1113d15000 class=external-link target=_blank rel=noopener>廖雪峰的 javascript 教程</a></li></ul></div><footer><div class=comments><script>let getTheme=window.localStorage&&window.localStorage.getItem("colorscheme"),themeInParams="github-light";getTheme==null&&(themeInParams!==""&&themeInParams!=="auto"?getTheme=themeInParams:getTheme=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");let theme=getTheme==="dark"?"github-dark":"github-light",s=document.createElement("script");s.src="https://utteranc.es/client.js",s.setAttribute("repo","joejztang/joejztang.github.io"),s.setAttribute("issue-term","pathname"),s.setAttribute("theme",theme),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></footer></article></section></div><footer class=footer><section class=container>©
1990 -
2025
130l
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-YNPYVVT1S7"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-YNPYVVT1S7")}</script></body></html>